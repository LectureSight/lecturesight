package cv.lecturesight.videoanalysis.rerdmann;

import cv.lecturesight.display.DisplayService;
import cv.lecturesight.framesource.FrameSource;
import cv.lecturesight.framesource.FrameSourceProvider;
import cv.lecturesight.gui.api.UserInterface;
import cv.lecturesight.objecttracker.ObjectTracker;
import cv.lecturesight.objecttracker.TrackerObject;
import cv.lecturesight.opencl.OpenCLService;
import cv.lecturesight.opencl.OpenCLService.Format;
import cv.lecturesight.opencl.api.ComputationRun;
import cv.lecturesight.opencl.api.OCLSignal;
import cv.lecturesight.util.conf.Configuration;
import cv.lecturesight.util.conf.ConfigurationListener;

import com.nativelibs4java.opencl.CLBuffer;
import com.nativelibs4java.opencl.CLImage2D;
import com.nativelibs4java.opencl.CLKernel;
import com.nativelibs4java.opencl.CLMem;
import com.nativelibs4java.opencl.CLQueue;

import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Properties;
import org.apache.felix.scr.annotations.Property;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.Service;
import org.osgi.service.component.ComponentContext;
import org.pmw.tinylog.Logger;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import java.nio.FloatBuffer;


//OSGI Definitionen
@Component(name = "lecturesight.videoanalysis", immediate = true)
@Service
@Properties({
  @Property(name = "osgi.command.scope", value = "va"),
  @Property(name = "osgi.command.function", value = {"reset"})//es gibt die klasse = funktion für konsole
})
public class VideoAnalysisRErdmann implements ObjectTracker, ConfigurationListener {

  final int MAX_REGIONS = 36; // maximum number of foreground regions analysed by this Tracker
  final int MAX_TARGETS = 6;  // maximum number of targets this Tracker can track
  final int TARGET_SIZE = 32; // average size of a target in scene
  final int image_height = 480;
  final int image_width = 640;
  //HistogramBlocks
  final int block_height = 8;
  final int block_width = 8;
  //NormalisationBlocks
  final int cell_heigth = 16;
  final int cell_width = 16;
  final int histogram_bins = 9;
    
  int descriptor_size = image_height*image_width/block_height*block_width*histogram_bins;


  // configuration properties for this service (resources/conf/default.properties)--
  private final static String PROPKEY_TESTPARAM = "param1"; //siehe Other Sources conf

  // variables holding the values of the configuration properties (updated by configurationChanged())
  int param1; //wird in der Konfiguation von Lecturesight angezeigt
  
  //OSGI Service
  @Reference
  Configuration config;       // configuration parameters (z.B. param1

  @Reference
  OpenCLService ocl;          // OpenCL service
  //OCL Signale=Kommunikation Graka CPU
  OCLSignal sig_START;        // signal triggering processing of new frame
  OCLSignal sig_VA_DONE;      // signal indicating that VideoAnalysis is done

  @Reference
  DisplayService dsps;        // display service

  @Reference
  FrameSourceProvider fsp;    // service providing the input FrameSource
  FrameSource fsrc;           // input FrameSource

  //Ausführung OpenCL in Java (2 Teile: Start (launch) z.B. Farbkonvertierung, Ende(land) OCLSignal ausgeben + Ergebnisse auslesen) siehe: 
  ComputationRun ocl_test_run;    // example of a ComputationRun

  // -- OpenCL Kernels --
  //CLKernel test_kernel;           // example of kernel used in ocl_test_run
  CLKernel sobel_kernel;
  CLKernel grayscale_kernel;
  CLKernel hog_kernel_gradient;
  CLKernel hog_kernel_normalization;

  // -- GPU Buffers -- (siehe openCL-Klasse)
  CLImage2D input_rgb;            // input image GPU buffer
  CLImage2D test_result_image;    // GPU buffer for result of ocl_test_run
  CLImage2D io_grayscale_image;
  CLImage2D hog_gradient_image;

  // GPU buffers for object data
  CLBuffer<Integer> centroids_gpu;      // GPU array of centroids of tracked objects [x1,y1,x2,y2,...,xN,yN]
  CLBuffer<Integer> bboxes_gpu;         // GPU array of bounding boxes of tracked objects [xa1,ya1,xb1,yb1,...,xaN,yaN,xbN,ybN]
  CLBuffer<Integer> head_pos_gpu;       // GPU array of head positions [x1,y1,x2,y2,...,xN,yN]
  
  // GPU buffers for HOG
  CLBuffer<Float> features_gpu;
  CLBuffer<Float> descriptor_gpu;
  CLBuffer<Float> norm_gpu;
  CLBuffer<Float> norm_factor_gpu;
  CLBuffer<Float> svm_y_gpu;
  CLBuffer<Float> prediction_gpu;

  // Host arrays for object data (Klone der GPU Buffer zum speichern der Ergebnisse)
  int[] region_centroids;               // recieves values from centroids_gpu
  int[] region_bboxes;                  // recieves values from bboxes_gpu
  int[] region_headpos;                 // recieves values from head_pos_gpu
  int numRegions;                       // count of foreground regions
  
  FloatBuffer outputBuffer;

  int numTargets = 0;                   // OUTPUT: current number of targets
  Target[] targets;                     // OUTPUT ARRAY: Targets in this array are displayed by the Tracker UI

  // dimensions of input images
  int[] imageWorkDim;         // work group size of per-pixel kernels

  // GPU max workgroup size
  long gpu_maxworkgroupsize;

  // initially loads configuration property values (hold die defaultProperties in den Code z.B. macimale Anz an Ziele)
  private void mapParameters() {
    param1 = config.getInt(PROPKEY_TESTPARAM);
  }

  // get OpenCL kernels
  private void getKernels() {
    //test_kernel = ocl.programs().getKernel("test", "test_processing"); //Kerneldatei, Kernelname
    sobel_kernel = ocl.programs().getKernel("sobel", "SobelDetector"); //Kerneldatei, Kernelname
    grayscale_kernel = ocl.programs().getKernel("grayscale", "grayscale_processing"); //Kerneldatei, Kernelname
    hog_kernel_gradient = ocl.programs().getKernel("hog", "compute_hog_gradient"); //Kerneldatei, Kernelname
    hog_kernel_normalization = ocl.programs().getKernel("hog", "compute_normalization"); //Kerneldatei, Kernelname
  }

  // allocates an OpenCL Image buffer (Allokiert Speicherplatz für Bilder hier für das Resultatbild) Sinnvoll für z.B. nn
  private CLImage2D allocImage2D(Format format, int[] dim) {
    return ocl.context().createImage2D(CLMem.Usage.InputOutput, format.getCLImageFormat(), dim[0], dim[1]);
  }

  // initialize GPU buffers (e.g. setting image buffers to black)
  private void initBuffers() {
    ocl.utils().setValues(0, 0, imageWorkDim[0], imageWorkDim[1], test_result_image, 0, 0, 0, 255);
  }

  // registers displays that show up in the UI
  private void registerDisplays() {
    dsps.registerDisplay("test_output", test_result_image, sig_VA_DONE); //Titel, GPU-Buffer, der dargestellt werden soll, Signal dass Ausgabe trigert)
    dsps.registerDisplay("hog_gradient_output", hog_gradient_image, sig_VA_DONE); //Titel, GPU-Buffer, der dargestellt werden soll, Signal dass Ausgabe trigert)
    dsps.registerDisplay("grayscale_output", io_grayscale_image, sig_VA_DONE); //Titel, GPU-Buffer, der dargestellt werden soll, Signal dass Ausgabe trigert)
  }

  // allocate GPU buffers and host arrays
  private void allocateBuffers() throws IllegalStateException {
    // obtain input image buffer from FrameSource
    input_rgb = fsrc.getImage();

    // allocate working buffers
    test_result_image = allocImage2D(Format.RGBA_UINT8, imageWorkDim);
    io_grayscale_image = allocImage2D(Format.RGBA_UINT8, imageWorkDim);
    hog_gradient_image = allocImage2D(Format.RGBA_UINT8, imageWorkDim);
    
    // allocate buffers and arrays for object data
    centroids_gpu = ocl.context().createIntBuffer(CLMem.Usage.InputOutput, MAX_REGIONS * 2);
    bboxes_gpu = ocl.context().createIntBuffer(CLMem.Usage.InputOutput, MAX_REGIONS * 4);
    head_pos_gpu = ocl.context().createIntBuffer(CLMem.Usage.InputOutput, MAX_REGIONS * 2);
    
    
    features_gpu = ocl.context().createFloatBuffer(CLMem.Usage.InputOutput,descriptor_size);
    descriptor_gpu = ocl.context().createFloatBuffer(CLMem.Usage.InputOutput,descriptor_size);
    norm_gpu = ocl.context().createFloatBuffer(CLMem.Usage.InputOutput,descriptor_size/9);    
    norm_factor_gpu = ocl.context().createFloatBuffer(CLMem.Usage.InputOutput,1);
    
    // init host arrays for object data
    region_centroids = new int[MAX_REGIONS * 2];
    region_bboxes = new int[MAX_REGIONS * 4];
    region_headpos = new int[MAX_REGIONS * 2];

    // init Targets array
    targets = new Target[MAX_TARGETS];
    
  }


  protected void activate(ComponentContext cc) {

    fsrc = fsp.getFrameSource();              // obtain frame source

    sig_START = fsrc.getSignal();             // obtain start signal
    sig_VA_DONE = ocl.getSignal("VA_DONE");   // create finish signal

    // determine input image dimensions (=work group size for image processing kernel)
    imageWorkDim = new int[]{fsrc.getWidth(), fsrc.getHeight()};

    // do the usual init steps
    mapParameters();      // get computation parameters from configuration
    getKernels();         // get kernels
    allocateBuffers();    // allocate GPU buffers
    initBuffers();        // initialize GPU buffers
    registerDisplays();   // register displays

    // set up and register ComputationRuns
    ocl_test_run = new ExampleComputationRun();
    ocl.registerLaunch(sig_START, ocl_test_run); //Ausführung des Computationruns wenn sig_START geworfen wird

    // set up and register Tracker UI
    UserInterface trackerUI = new TrackerUI(this);
    cc.getBundleContext().registerService(UserInterface.class.getName(), trackerUI, null);

    Logger.info("Activated.");
  }

  protected void deactivate(ComponentContext cc) throws Exception {
    Logger.info("Deactivated.");
  }


  class ExampleComputationRun implements ComputationRun {

    @Override
    public void launch(CLQueue queue) {

      // Ignore when shutting down
      if (ocl == null)
        return;

      sobel_kernel.setArgs(input_rgb, test_result_image);
      sobel_kernel.enqueueNDRange(queue, imageWorkDim);
      grayscale_kernel.setArgs(input_rgb, io_grayscale_image);
      grayscale_kernel.enqueueNDRange(queue, imageWorkDim);         
      hog_kernel_gradient.setArgs(io_grayscale_image,hog_gradient_image,features_gpu);
      hog_kernel_gradient.enqueueNDRange(queue, imageWorkDim);         
      outputBuffer = features_gpu.read(queue);
      System.out.println("Float Buffer");
      

    }

    @Override
    public void land() { //Auslesen von Ergebnissen
      // Ignore when shutting down
      if (ocl == null)
        return;
      ocl.castSignal(sig_VA_DONE);
    }
  }


// cv.lecturesight.util.conf.ConfigurationListener methods  ____________________
//

  @Override //Falls Parameter Live gädert werden
  public void configurationChanged() {
    if (param1 != config.getInt(PROPKEY_TESTPARAM)) {
      param1 = config.getInt(PROPKEY_TESTPARAM);
      Logger.info("Setting param1 to {}", param1);
    }
  }


// cv.lecturesight.objecttracker.ObjectTracker methods _________________________
//

  @Override
  public OCLSignal getSignal() {
    return sig_VA_DONE;
  }

  @Override
  public TrackerObject getObject(int id) {
    for (Target t : targets) {
      if (t != null && t.id == id) {
        return t.to;
      }
    }
    return null;
  }

  @Override
  public boolean isCurrentlyTracked(TrackerObject object) {
    for (Target t : targets) {
      if (t != null && t.id == object.getId()) {
        return true;
      }
    }
    return false;
  }

  @Override
  public void discardObject(TrackerObject object) {
    for (Target t : targets) {
      if (t != null && t.id == object.getId()) {
        //discardTarget(t);
      }
    }
  }

  @Override
  public Map<Integer, TrackerObject> getAllObjects() {
    Map m = new HashMap<Integer, TrackerObject>();
    for (Target t : targets) {
      if (t != null) {
        m.put(t.id, t.to);
      }
    }
    return m;
  }

  @Override
  public List<TrackerObject> getCurrentlyTracked() {
    long seen_before = System.currentTimeMillis();
    List l = new LinkedList<TrackerObject>();
    for (Target t : targets) {
      if ((t != null) && (t.first_seen < seen_before)) {
        l.add(t.to);
      }
    }
    return l;
  }

  // Console Commands __________________________________________________________
  public void reset(String[] args) {
    for (int i = 0; i < MAX_TARGETS; i++) {
      targets[i] = null;
    }
    numTargets = 0;
    Logger.info("Clearing target list.");
  }
}

